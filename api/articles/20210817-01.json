{"title":"论文汇总","uid":"facac003c540bc301a5f0af70e300a42","slug":"20210817-01","date":"2021-08-16T16:00:00.000Z","updated":"2021-11-16T08:49:33.508Z","comments":true,"path":"api/articles/20210817-01.json","keywords":null,"cover":"file/20210817-01.jpg","content":"<h1 id=\"Distributed-System\"><a href=\"#Distributed-System\" class=\"headerlink\" title=\"Distributed System\"></a>Distributed System</h1><p><em>Wait-Free Queues With Multiple Enqueuers and Dequeuers</em><br><a href=\"http://www.cs.technion.ac.il/~erez/Papers/wfquque-ppopp.pdf\" target=\"_blank\">http://www.cs.technion.ac.il/~erez/Papers/wfquque-ppopp.pdf</a><br>idea:<br>        The newly-enqueue task get a phase number which is bigger than the previous tasks, then trying to help the tasks with smaller phase number. When there is no task with smaller phase number, this one can do the deque operation safely (may helped by the one enter the queue after this task), since there is no other work to do.</p>\n<p><em>Object Storage on CRAQ</em><br><a href=\"http://nil.csail.mit.edu/6.824/2020/papers/craq.pdf\" target=\"_blank\">http://nil.csail.mit.edu/6.824/2020/papers/craq.pdf</a> </p>\n<p>idea:<br>        Chain-based replication make strong consistency. Head node is in charge of the write oprtion, while the tail node take read opration. Once the head node receive a write command, it replicate down through the chain until it reachs the end, then the operation is considered commited since all the backup-server receive the command. Finally, the read operation that always sent to the last node, can only read the commited data.</p>\n<p><em>Zookeeper</em><br>[Link]<br>idea:</p>\n<p><em>Amazon Aurora: Design Considerations for High Throughput Cloud-Native Relational Databases</em></p>\n<p><a href=\"http://nil.csail.mit.edu/6.824/2020/papers/aurora.pdf\">http://nil.csail.mit.edu/6.824/2020/papers/aurora.pdf</a></p>\n<p>idea:</p>\n<p>In Aurora, we have chosen a design point of tolerating (a) losing an entire AZ and one additional node (AZ+1) without losing data, and (b) losing an entire AZ without impacting the ability to write data. We achieve this by replicating each data item 6 ways across 3 AZs with 2 copies of each item in each AZ. We use a quorum model with 6 votes (V = 6), a write quorum of 4/6 (Vw = 4), and a read quorum of 3/6 (Vr = 3). With such a model, we can (a) lose a single AZ and one additional node (a failure of 3 nodes) without losing read availability, and (b) lose any two nodes, including a single AZ failure and maintain write availability. Ensuring read quorum enables us to rebuild write quorum by adding additional replica copies.</p>\n<p>Since we can withhold the loss of one AZ server, it means that at some time when there is no failure, we can update(rollback) one of our system or software  at a time, and the system still works well.</p>\n","text":"Distributed SystemWait-Free Queues With Multiple Enqueuers and Dequeuershttp://www.cs.technion.ac.il/~erez/Papers/wfquque-ppopp.pdfidea: The...","link":"","photos":[],"count_time":{"symbolsCount":"2.1k","symbolsTime":"2 mins."},"categories":[{"name":"Share","slug":"Share","count":4,"path":"api/categories/Share.json"},{"name":"Study","slug":"Share/Study","count":1,"path":"api/categories/Share/Study.json"}],"tags":[{"name":"Distributed system","slug":"Distributed-system","count":1,"path":"api/tags/Distributed-system.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Distributed-System\"><span class=\"toc-text\">Distributed System</span></a></li></ol>","author":{"name":"Wakkana","slug":"blog-author","avatar":"/file/avator.jpeg","link":"/","description":"Res tantum valet quantum vendi potest.","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"weibo":{"icon":"/svg/weibo.svg","link":"https://weibo.com/6962193334/profile?topnav=1&wvr=6"}}}},"mapped":true,"prev_post":{"title":"C++ json","uid":"2f0370a0b05817d7bce5f9e84fcb2693","slug":"20210831-01","date":"2021-08-30T20:35:00.729Z","updated":"2021-11-16T08:52:37.393Z","comments":true,"path":"api/articles/20210831-01.json","keywords":null,"cover":"file/no.jpeg","text":"&#123; ​ &quot;ACM-model&quot;: &#123; ​ &quot;prefix&quot;: &quot;acm&quot;, ​ &quot;body&quot;: [ ​ &quot;#include &lt;bits&#x2F;stdc++.h&...","link":"","photos":[],"count_time":{"symbolsCount":"2k","symbolsTime":"2 mins."},"categories":[{"name":"Share","slug":"Share","count":4,"path":"api/categories/Share.json"}],"tags":[],"author":{"name":"Wakkana","slug":"blog-author","avatar":"/file/avator.jpeg","link":"/","description":"Res tantum valet quantum vendi potest.","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"weibo":{"icon":"/svg/weibo.svg","link":"https://weibo.com/6962193334/profile?topnav=1&wvr=6"}}}}},"next_post":{"title":"Kubernetesの学习笔记","uid":"84c50d5ee6f451bc51fe31f3e7ac9569","slug":"20210621-01","date":"2021-06-20T16:00:00.000Z","updated":"2021-11-16T08:49:28.946Z","comments":true,"path":"api/articles/20210621-01.json","keywords":null,"cover":"file/cover1.jpeg","text":"Kubernetes&emsp;&emsp; 容器编排的工具 资源清单&emsp;&emsp; Yam :::details 什么是资源？ dd :::Master : 集群控制节点，每个集群需要至少一个master节点负责集群的管控Node : 工作负载节点，由master分配...","link":"","photos":[],"count_time":{"symbolsCount":845,"symbolsTime":"1 mins."},"categories":[{"name":"Study","slug":"Study","count":1,"path":"api/categories/Study.json"}],"tags":[{"name":"Kubernetes","slug":"Kubernetes","count":1,"path":"api/tags/Kubernetes.json"}],"author":{"name":"Wakkana","slug":"blog-author","avatar":"/file/avator.jpeg","link":"/","description":"Res tantum valet quantum vendi potest.","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"weibo":{"icon":"/svg/weibo.svg","link":"https://weibo.com/6962193334/profile?topnav=1&wvr=6"}}}}}}