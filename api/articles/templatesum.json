{"title":"几个常见的模版","uid":"afe4f8618e63693f296fa53d89e46c0a","slug":"templatesum","date":"2021-05-15T16:00:00.000Z","updated":"2021-05-16T06:02:12.085Z","comments":true,"path":"api/articles/templatesum.json","keywords":null,"cover":"file/cover2.jpeg","content":"<div class=\"custom-quote tip\">\n<span class=\"custom-quote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12.01 15C12.01 14.5 12.01 14.5 12.01 14.5C12.04 13.75 13 13.46 14.04 12.2C14.41 11.74 14.69 11.41 14.86 10.85C15.15 9.95 14.92 9.18 14.86 9.02C14.8 8.79 14.52 8 13.72 7.46C13.06 7.02 12.42 7 12.14 7C11.9 7 11.36 7 10.78 7.3C10.28 7.56 9.98 7.9 9.83 8.1C9.24 8.82 9.06 9.63 9 10.06\"></path>\n<path stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M11.99 18H12.01\"></path>\n</svg></span>\n<p class=\"custom-quote-title\">前言</p>\n<p>在比赛中经常会有通用的方法，在时间紧迫的比赛中花时间默写已有的模版是很耗费时间的，在套用模版后加上针对性改进往往会有事半功倍的效果，但切忌套用不熟悉的模版。在搞清楚原理后使用才能达成节省时间、专注于解决问题上。以下模版为个人使用，是简化的版本，如并查集没有按轶合并等，在效率上略显底下。</p>\n</div>\n<hr>\n<h3 id=\"质数打表\"><a href=\"#质数打表\" class=\"headerlink\" title=\"质数打表\"></a>质数打表</h3><pre class=\"language-c++\" data-language=\"c++\"><code class=\"language-c++\">void solve()&#123;\n    int n; cin &gt;&gt; n;\n    vector&lt;int&gt; d(n,1);\n    for(int i &#x3D; 2; i &lt;&#x3D; n; i++)&#123;\n        if(!d[i]) continue;\n        for(int j &#x3D; 2; j &lt; i; j++)&#123;\n            if(i%j &#x3D;&#x3D; 0)&#123;\n                for(int k &#x3D; 1; k * i &lt;&#x3D; n; k++)&#123;\n                    d[k*i] &#x3D; false; \n                &#125;\n            &#125;\n        &#125;\n    &#125;\n    cout &lt;&lt; &quot;vector&lt;int&gt; primes &#x3D; &#123;&quot;;\n    for(int i &#x3D; 1; i &lt;&#x3D; n; i++)&#123;\n        if(d[i]) &#123;\n            if(i &gt; 0) cout &lt;&lt; &#39;,&#39;;\n            cout &lt;&lt; i;\n        &#125;\n    &#125;\n    cout &lt;&lt; &quot;&#125;;&quot;;\n&#125;</code></pre>\n\n<h3 id=\"链式前向星存图\"><a href=\"#链式前向星存图\" class=\"headerlink\" title=\"链式前向星存图\"></a>链式前向星存图</h3><pre class=\"language-c++\" data-language=\"c++\"><code class=\"language-c++\">const int maxn &#x3D; 1e6;\nstruct E&#123;\n    int to,w,next;\n&#125;Edge[maxn];\nint tot &#x3D; 0, h[maxn];\ninline void addegde(int u,int v,int w)&#123;\n    Edge[tot].to &#x3D; v;\n    Edge[tot].w &#x3D; w;\n    Edge[tot].next &#x3D; h[u];\n    h[u] &#x3D; tot++;\n&#125;</code></pre>\n\n<h3 id=\"并查集\"><a href=\"#并查集\" class=\"headerlink\" title=\"并查集\"></a>并查集</h3><pre class=\"language-c++\" data-language=\"c++\"><code class=\"language-c++\">const int maxn &#x3D; 100005;\nint f[maxn];\nvoid init(int n)&#123;\n    for(int i &#x3D; 0; i &lt; n; i++)&#123;\n        f[i] &#x3D; i;\n    &#125;\n&#125;\nint find(int x)&#123;\n    return x &#x3D;&#x3D; f[x] ? x : f[x] &#x3D; find(f[x]);\n&#125;\nvoid merge(int a,int b)&#123;\n    f[find(a)] &#x3D; find(b);\n&#125;</code></pre>\n\n<h3 id=\"后缀自动机\"><a href=\"#后缀自动机\" class=\"headerlink\" title=\"后缀自动机\"></a>后缀自动机</h3><pre class=\"language-c++\" data-language=\"c++\"><code class=\"language-c++\">struct Node&#123;\n    int len, link;\n    unordered_map&lt;int,int&gt; go;\n&#125;a[20000];\nint sz,last;\nvoid saminit()&#123;\n    sz &#x3D; last &#x3D; 0;\n    a[0].len &#x3D; 0;\n    a[0].link &#x3D; -1;\n    ++sz;\n&#125;\nvoid add(char c)&#123;\n    int cur &#x3D; sz++;\n    a[cur].len &#x3D; a[last].len+1;\n    int p &#x3D; last;\n    while(p !&#x3D; -1 &amp;&amp; !a[p].go.count(c-&#39;a&#39;))&#123;\n        a[p].go[c-&#39;a&#39;] &#x3D; cur;\n        p &#x3D; a[p].link;  \n    &#125;\n    if(p &#x3D;&#x3D; -1) a[cur].link &#x3D; 0;\n    else&#123;\n        int q &#x3D; a[p].go[c-&#39;a&#39;];\n        if(a[q].len &#x3D;&#x3D; a[p].len+1) a[cur].link &#x3D; q;\n        else&#123;\n            int clone &#x3D; sz++;\n            a[clone].len &#x3D; a[p].len+1;\n            a[clone].go &#x3D; a[q].go, a[clone].link &#x3D; a[q].link;\n            while(p !&#x3D; -1 &amp;&amp; a[p].go[c-&#39;a&#39;] &#x3D;&#x3D; q)&#123;\n                a[p].go[c-&#39;a&#39;] &#x3D; clone;\n                p &#x3D; a[p].link;\n            &#125;\n            a[cur].link &#x3D; a[q].link &#x3D; clone;\n        &#125;\n    &#125;\n    last &#x3D; cur;\n&#125;</code></pre>","feature":true,"pinned":true,"text":" 前言 在比赛中经常会有通用的方法，在时间紧迫的比赛中花时间默写已有的模版是很耗费时间的，在套用模版后加上针对性改进往往会有事半功倍的效果，但切忌套用不熟悉的模版。在搞清楚原理后使用才能达成节省时间、专注于解决问题上。以下模版为个人使用，是简化的版本，如并查集没有按轶合并等，在效...","link":"","photos":[],"count_time":{"symbolsCount":"2.6k","symbolsTime":"2 mins."},"categories":[],"tags":[{"name":"algorithm","slug":"algorithm","count":1,"path":"api/tags/algorithm.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%B4%A8%E6%95%B0%E6%89%93%E8%A1%A8\"><span class=\"toc-text\">质数打表</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%93%BE%E5%BC%8F%E5%89%8D%E5%90%91%E6%98%9F%E5%AD%98%E5%9B%BE\"><span class=\"toc-text\">链式前向星存图</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%B9%B6%E6%9F%A5%E9%9B%86\"><span class=\"toc-text\">并查集</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%90%8E%E7%BC%80%E8%87%AA%E5%8A%A8%E6%9C%BA\"><span class=\"toc-text\">后缀自动机</span></a></li></ol>","author":{"name":"Wakkana","slug":"blog-author","avatar":"/file/avator.jpeg","link":"/","description":"Res tantum valet quantum vendi potest.","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"weibo":{"icon":"/svg/weibo.svg","link":"https://weibo.com/6962193334/profile?topnav=1&wvr=6"}}}},"mapped":true,"prev_post":{},"next_post":{"title":"C++中的二进制技巧","uid":"ceb531fd493e11e5f90d618867a2a344","slug":"binary tricks","date":"2021-05-15T16:00:00.000Z","updated":"2021-05-29T17:24:38.561Z","comments":true,"path":"api/articles/binary tricks.json","keywords":null,"cover":"file/cover2.jpeg","text":"判断-1int i &#x3D; -1; &#x2F;&#x2F; means the binary expression of i is 111111111···11 &#x2F;&#x2F; at the same time the &#39;~&#39; operation...","link":"","photos":[],"count_time":{"symbolsCount":971,"symbolsTime":"1 mins."},"categories":[],"tags":[{"name":"math","slug":"math","count":1,"path":"api/tags/math.json"}],"author":{"name":"Wakkana","slug":"blog-author","avatar":"/file/avator.jpeg","link":"/","description":"Res tantum valet quantum vendi potest.","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"weibo":{"icon":"/svg/weibo.svg","link":"https://weibo.com/6962193334/profile?topnav=1&wvr=6"}}}},"feature":true,"pinned":true}}