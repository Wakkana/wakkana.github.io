[{"id":"afe4f8618e63693f296fa53d89e46c0a","title":"几个常见的模版","content":"\n\n\n\n\n\n前言\n在比赛中经常会有通用的方法，在时间紧迫的比赛中花时间默写已有的模版是很耗费时间的，在套用模版后加上针对性改进往往会有事半功倍的效果，但切忌套用不熟悉的模版。在搞清楚原理后使用才能达成节省时间、专注于解决问题上。以下模版为个人使用，是简化的版本，如并查集没有按轶合并等，在效率上略显底下。\n\n\n质数打表void solve()&#123;\n    int n; cin &gt;&gt; n;\n    vector&lt;int&gt; d(n,1);\n    for(int i &#x3D; 2; i &lt;&#x3D; n; i++)&#123;\n        if(!d[i]) continue;\n        for(int j &#x3D; 2; j &lt; i; j++)&#123;\n            if(i%j &#x3D;&#x3D; 0)&#123;\n                for(int k &#x3D; 1; k * i &lt;&#x3D; n; k++)&#123;\n                    d[k*i] &#x3D; false; \n                &#125;\n            &#125;\n        &#125;\n    &#125;\n    cout &lt;&lt; &quot;vector&lt;int&gt; primes &#x3D; &#123;&quot;;\n    for(int i &#x3D; 1; i &lt;&#x3D; n; i++)&#123;\n        if(d[i]) &#123;\n            if(i &gt; 0) cout &lt;&lt; &#39;,&#39;;\n            cout &lt;&lt; i;\n        &#125;\n    &#125;\n    cout &lt;&lt; &quot;&#125;;&quot;;\n&#125;\n\n链式前向星存图const int maxn &#x3D; 1e6;\nstruct E&#123;\n    int to,w,next;\n&#125;Edge[maxn];\nint tot &#x3D; 0, h[maxn];\ninline void addegde(int u,int v,int w)&#123;\n    Edge[tot].to &#x3D; v;\n    Edge[tot].w &#x3D; w;\n    Edge[tot].next &#x3D; h[u];\n    h[u] &#x3D; tot++;\n&#125;\n\n并查集const int maxn &#x3D; 100005;\nint f[maxn];\nvoid init(int n)&#123;\n    for(int i &#x3D; 0; i &lt; n; i++)&#123;\n        f[i] &#x3D; i;\n    &#125;\n&#125;\nint find(int x)&#123;\n    return x &#x3D;&#x3D; f[x] ? x : f[x] &#x3D; find(f[x]);\n&#125;\nvoid merge(int a,int b)&#123;\n    f[find(a)] &#x3D; find(b);\n&#125;\n\n后缀自动机struct Node&#123;\n    int len, link;\n    unordered_map&lt;int,int&gt; go;\n&#125;a[20000];\nint sz,last;\nvoid saminit()&#123;\n    sz &#x3D; last &#x3D; 0;\n    a[0].len &#x3D; 0;\n    a[0].link &#x3D; -1;\n    ++sz;\n&#125;\nvoid add(char c)&#123;\n    int cur &#x3D; sz++;\n    a[cur].len &#x3D; a[last].len+1;\n    int p &#x3D; last;\n    while(p !&#x3D; -1 &amp;&amp; !a[p].go.count(c-&#39;a&#39;))&#123;\n        a[p].go[c-&#39;a&#39;] &#x3D; cur;\n        p &#x3D; a[p].link;  \n    &#125;\n    if(p &#x3D;&#x3D; -1) a[cur].link &#x3D; 0;\n    else&#123;\n        int q &#x3D; a[p].go[c-&#39;a&#39;];\n        if(a[q].len &#x3D;&#x3D; a[p].len+1) a[cur].link &#x3D; q;\n        else&#123;\n            int clone &#x3D; sz++;\n            a[clone].len &#x3D; a[p].len+1;\n            a[clone].go &#x3D; a[q].go, a[clone].link &#x3D; a[q].link;\n            while(p !&#x3D; -1 &amp;&amp; a[p].go[c-&#39;a&#39;] &#x3D;&#x3D; q)&#123;\n                a[p].go[c-&#39;a&#39;] &#x3D; clone;\n                p &#x3D; a[p].link;\n            &#125;\n            a[cur].link &#x3D; a[q].link &#x3D; clone;\n        &#125;\n    &#125;\n    last &#x3D; cur;\n&#125;","slug":"templatesum","date":"2021-05-15T16:00:00.000Z","categories_index":"","tags_index":"algorithm","author_index":"Wakkana"},{"id":"ceb531fd493e11e5f90d618867a2a344","title":"C++中的二进制技巧","content":"判断-1int i &#x3D; -1; \n&#x2F;&#x2F; means the binary expression of i is 111111111···11\n&#x2F;&#x2F; at the same time the &#39;~&#39; operation flip every bit of i\n&#x2F;&#x2F; then the binary expression of i is 000000000···000\nassert(~i &#x3D;&#x3D; 0);\ncout &lt;&lt; i &lt;&lt; endl;\n\n判断1个数&#x2F;&#x2F;1\n\n&#x2F;&#x2F;system buildin function __builtin_popcount()\nint a &#x3D; 1234124;  \n&#x2F;&#x2F;binary expression is 100101101010011001100\ncout &lt;&lt; __builtin_popcount(a) &lt;&lt; endl;\n&#x2F;&#x2F;tht outcome is 10\n\n&#x2F;&#x2F;2\n\n&#x2F;&#x2F;use the math\n&#x2F;&#x2F;the operation i &amp; (i - 1) \nint i &#x3D; 1234124;\n&#x2F;&#x2F;binary expression is 100101101010011001100\n&#x2F;&#x2F;also i-1 is          100101101010011001011\n&#x2F;&#x2F;the the &amp; operation  100101101010011001000\n&#x2F;&#x2F;see! the last 1 is gone\nint cnt &#x3D; 0;\nwhile(i)&#123;\n    i &amp;&#x3D; (i-1);\n    cnt++;\n&#125;\ncout &lt;&lt; cnt &lt;&lt; endl;\n&#x2F;&#x2F;the outcome is 10","slug":"binary tricks","date":"2021-05-15T16:00:00.000Z","categories_index":"","tags_index":"math","author_index":"Wakkana"},{"id":"987c8f5655d353d42a8d96124ecde8bc","title":"just for show","content":"download\n\nClick to see more\nFusce rutrum venenatis eros in hendrerit. Pellentesque habitant morbi tristique senectus et netus et malesuada fames ac turpis egestas. Nullam eget risus egestas, aliquet ipsum sed, volutpat tortor. Proin finibus tortor ac mauris finibus rutrum. Nullam tincidunt arcu eu urna ullamcorper, eu ultricies turpis ornare. Morbi id sollicitudin orci. Proin lobortis vehicula nibh a ornare. Cras sodales eu ligula quis fermentum. Proin eu ultrices leo, quis iaculis justo. Sed dictum, nulla sit amet imperdiet commodo, libero sapien semper justo, ut lobortis elit nunc vitae ante. Nullam lobortis odio quam, ac condimentum elit posuere vitae. Sed ornare, odio et rutrum varius, lorem eros gravida urna, in pharetra sapien justo non magna.\n\ndetails content\ndetails new line\n\nconsole.log('hello world')\n\n\n\n","slug":"hello-world","date":"2021-03-31T16:00:00.000Z","categories_index":"收录","tags_index":"Mac,Crack","author_index":"Wakkana"}]